import{D as V,H as B,F as w,h as G,L as u,i as b}from"./three.module.99621659.js";class $ extends V{constructor(R){super(R);this.type=B}parse(R){const g=function(r,t){switch(r){case 1:console.error("THREE.RGBELoader Read Error: "+(t||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(t||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(t||""));break;default:case 4:console.error("THREE.RGBELoader: Error: "+(t||""))}return-1},k=`
`,T=function(r,t,i){t=t||1024;let s=r.pos,o=-1,e=0,l="",a=String.fromCharCode.apply(null,new Uint16Array(r.subarray(s,s+128)));for(;0>(o=a.indexOf(k))&&e<t&&s<r.byteLength;)l+=a,e+=a.length,s+=128,a+=String.fromCharCode.apply(null,new Uint16Array(r.subarray(s,s+128)));return-1<o?(i!==!1&&(r.pos+=e+o+1),l+a.slice(0,o)):!1},D=function(r){const t=/^#\?(\S+)/,i=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,n=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,s=/^\s*FORMAT=(\S+)\s*$/,o=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,e={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let l,a;if(r.pos>=r.byteLength||!(l=T(r)))return g(1,"no header found");if(!(a=l.match(t)))return g(3,"bad initial token");for(e.valid|=1,e.programtype=a[1],e.string+=l+`
`;l=T(r),l!==!1;){if(e.string+=l+`
`,l.charAt(0)==="#"){e.comments+=l+`
`;continue}if((a=l.match(i))&&(e.gamma=parseFloat(a[1])),(a=l.match(n))&&(e.exposure=parseFloat(a[1])),(a=l.match(s))&&(e.valid|=2,e.format=a[1]),(a=l.match(o))&&(e.valid|=4,e.height=parseInt(a[1],10),e.width=parseInt(a[2],10)),e.valid&2&&e.valid&4)break}return e.valid&2?e.valid&4?e:g(3,"missing image size specifier"):g(3,"missing format specifier")},S=function(r,t,i){const n=t;if(n<8||n>32767||r[0]!==2||r[1]!==2||r[2]&128)return new Uint8Array(r);if(n!==(r[2]<<8|r[3]))return g(3,"wrong scanline width");const s=new Uint8Array(4*t*i);if(!s.length)return g(4,"unable to allocate buffer space");let o=0,e=0;const l=4*n,a=new Uint8Array(4),_=new Uint8Array(l);let M=i;for(;M>0&&e<r.byteLength;){if(e+4>r.byteLength)return g(1);if(a[0]=r[e++],a[1]=r[e++],a[2]=r[e++],a[3]=r[e++],a[0]!=2||a[1]!=2||(a[2]<<8|a[3])!=n)return g(3,"bad rgbe scanline format");let d=0,h;for(;d<l&&e<r.byteLength;){h=r[e++];const m=h>128;if(m&&(h-=128),h===0||d+h>l)return g(3,"bad scanline data");if(m){const E=r[e++];for(let f=0;f<h;f++)_[d++]=E}else _.set(r.subarray(e,e+h),d),d+=h,e+=h}const H=n;for(let m=0;m<H;m++){let E=0;s[o]=_[m+E],E+=n,s[o+1]=_[m+E],E+=n,s[o+2]=_[m+E],E+=n,s[o+3]=_[m+E],o+=4}M--}return s},U=function(r,t,i,n){const s=r[t+3],o=Math.pow(2,s-128)/255;i[n+0]=r[t+0]*o,i[n+1]=r[t+1]*o,i[n+2]=r[t+2]*o,i[n+3]=1},N=function(r,t,i,n){const s=r[t+3],o=Math.pow(2,s-128)/255;i[n+0]=G.toHalfFloat(Math.min(r[t+0]*o,65504)),i[n+1]=G.toHalfFloat(Math.min(r[t+1]*o,65504)),i[n+2]=G.toHalfFloat(Math.min(r[t+2]*o,65504)),i[n+3]=G.toHalfFloat(1)},y=new Uint8Array(R);y.pos=0;const p=D(y);if(p!==-1){const r=p.width,t=p.height,i=S(y.subarray(y.pos),r,t);if(i!==-1){let n,s,o,e;switch(this.type){case w:e=i.length/4;const l=new Float32Array(e*4);for(let _=0;_<e;_++)U(i,_*4,l,_*4);n=l,o=w;break;case B:e=i.length/4;const a=new Uint16Array(e*4);for(let _=0;_<e;_++)N(i,_*4,a,_*4);n=a,o=B;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type);break}return{width:r,height:t,data:n,header:p.string,gamma:p.gamma,exposure:p.exposure,format:s,type:o}}}return null}setDataType(R){return this.type=R,this}load(R,L,F,I){function A(c,g){switch(c.type){case w:c.encoding=u,c.minFilter=b,c.magFilter=b,c.generateMipmaps=!1,c.flipY=!0;break;case B:c.encoding=u,c.minFilter=b,c.magFilter=b,c.generateMipmaps=!1,c.flipY=!0;break}L&&L(c,g)}return super.load(R,A,F,I)}}export{$ as R};
